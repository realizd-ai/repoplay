#!/bin/bash

set -ou pipefail

# Uncomment for debugging
#export PS4='+${LINENO}: '
#set -x

print_xmlhelp() {
  cat <<EOF
<operations>
  <!-- Creates a new file -->
  <operation type="create">
    <destinationPath>/absolute-path/ContactForm.tsx</destinationPath>
    <content><![CDATA[import React from 'react';
export default function ContactForm() { return <form>...</form>; }
    ]]></content>
  </operation>

  <!-- Updates/replaces contents of an existing file -->
  <operation type="update">
    <sourcePath>/absolute-path/ContactForm.tsx</sourcePath>
    <content><![CDATA[import React from 'react';
export default function ContactForm() { return <form>...</form>; }
    ]]></content>
  </operation>

  <!-- Deletes an existing file -->
  <operation type="delete">
    <sourcePath>/absolute-path/OldComponent.tsx</sourcePath>
  </operation>

  <!-- Moves or renames a file -->
  <operation type="move">
    <sourcePath>/absolute-path/LegacyButton.tsx</sourcePath>
    <destinationPath>/absolute-path/ui/LegacyButton.tsx</destinationPath>
  </operation>

  <!-- Duplicates an existing file -->
  <operation type="dup">
    <sourcePath>/absolute-path/src/components/Template.tsx</sourcePath>
    <destinationPath>/absolute-path/src/components/TemplateCopy.tsx</destinationPath>
  </operation>
</operations>
EOF
}

print_help() {
  cat <<EOF
Usage: repoplay [OPTION]... XML-PATCH-FILE
Apply repository changes from an XML file.

Options:
  -h, --help       Show this help message and exit
  -x, --xmlhelp    Show the XML format of the patch file 
  -v, --verbose    Enable verbose output
  -d, --dry-run    Validate input and show planned actions without modifying files

Example:
  repoplay changes.xml
  repoplay -v -d changes.xml
EOF
}

# Globals
VERBOSE=false
DRY_RUN=false
BACKUPS=()

# Log function (only logs if verbose is enabled)
log() {
  if [ "$VERBOSE" = true ]; then
    echo "repoplay: $1"
  fi
}

# Cleanup function (restores backups on error)
cleanup() {
  if [ "${#BACKUPS[@]:-0}" -gt 0 ]; then
    echo "repoplay: Error occurred. Restoring backups..."

    for backup in "${BACKUPS[@]}"; do
      original="${backup%.tmp}"
      if [ -f "$backup" ]; then
        mv "$backup" "$original"
        log "Restored $original from $backup"
      fi
    done
  fi

  echo "repoplay: no files have been modified"
  exit 1
}

# executes if any command returns a non-zero exit status
unhandled_error() {
    echo "repoplay: An unhandled non-zero exit status has been returned"
    cleanup
}

trap unhandled_error ERR

# Check for xmlstarlet
if ! command -v xmlstarlet >/dev/null 2>&1; then
  echo "repoplay: Error: xmlstarlet is not installed"
  echo "repoplay: Please install it using: 'sudo apt-get install xmlstarlet' or 'brew install xmlstarlet'"
  exit 1
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      exit 0
      ;;
    -x|--xmlhelp)
      print_xmlhelp
      exit 0
      ;;
    -v|--verbose)
      VERBOSE=true
      shift
      ;;
    -d|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -*) # Detect unknown options
      echo "repoplay: Error: Unknown option '$1'"
      exit 1
      ;;
    *) # Handle positional arguments
      if [[ -z "${INPUT_FILE:-}" ]]; then
        INPUT_FILE="$1"
      else
        echo "repoplay: Error: Unexpected argument '$1'"
        exit 1
      fi
      shift
      ;;
  esac
done

if [[ -z "${INPUT_FILE:-}" ]]; then
  echo "repoplay: Error: Exactly one input file must be specified. Use -h for help"
  exit 1
fi

if [ ! -f "$INPUT_FILE" ]; then
  echo "repoplay: Error: Input file '$INPUT_FILE' does not exist"
  exit 1
fi

log "Reading XML from $INPUT_FILE"

# Validate XML format
if ! xmlstarlet val --well-formed "$INPUT_FILE" >/dev/null 2>&1; then
  echo "repoplay: Error: Invalid XML format in $INPUT_FILE"
  exit 1
fi
log "XML format is valid"

# Parse XML operations
OPERATIONS=$(xmlstarlet sel -t -m "/operations/operation" -c "." "$INPUT_FILE")
if [ -z "$OPERATIONS" ]; then
  echo "repoplay: Error: No operations found in the input file"
  exit 1
fi
log "Parsed operations"

# Pre-check phase
log "Pre-checking all operations"
xmlstarlet sel -t -m "/operations/operation" \
    -v "concat(@type,'|',count(preceding::operation) + 1)" -n "$INPUT_FILE" | \
    while IFS='|' read -r type pos; do

  case "$type" in
    create)
      dst=$(xmlstarlet sel -t -m "/operations/operation[@type='create' and \
        count(preceding::operation) + 1=$pos]" -v "destinationPath" "$INPUT_FILE")
      log "Operation $type found at position $pos, destinationPath=$dst"

      if [ -f "$dst" ]; then
        echo "repoplay: Error: Destination file '$dst' already exists for create operation"
        exit 1
      fi
      ;;

    update|delete|move|dup)
      src=$(xmlstarlet sel -t -m "/operations/operation[@type='$type' and \
        count(preceding::operation) + 1=$pos]" -v "sourcePath" "$INPUT_FILE")
      log "Operation $type found at position $pos, sourcePath=$src"

      if [ ! -f "$src" ]; then
        echo "repoplay: Error: Source file '$src' does not exist for $type operation"
        exit 1
      fi

      if [[ "$type" == "update" || "$type" == "delete" || "$type" == "move" ]]; then
        backup="$src.tmp"
        cp "$src" "$backup"
        BACKUPS+=("$backup")
        log "Backed up $src to $backup"
      fi
      ;;

    *)
      echo "repoplay: Error: Invalid operation '$type' in pre-check phase"
      exit 1
      ;;
  esac
done

# was exit 1 called inside the while loop (pipeline means an exit in the while is in a sub-process)
if [ $? -ne 0 ]; then
  exit 1
fi

if [ "$DRY_RUN" = true ]; then
  log "Dry run beginning..."
else
  log "Applying operations..."
fi

# Apply operations
xmlstarlet sel -t -m "/operations/operation" \
    -v "concat(@type,'|',count(preceding::operation) + 1)" -n "$INPUT_FILE" | \
    while IFS='|' read -r type pos; do

  log "Operation $type found at position $pos"

  case "$type" in
    create)
      dst=$(xmlstarlet sel -t -m "/operations/operation[@type='create' and \
        count(preceding::operation) + 1=$pos]" \
        -v "destinationPath" "$INPUT_FILE")
      content=$(xmlstarlet sel -t -m "/operations/operation[@type='create' and \
        count(preceding::operation) + 1=$pos]" \
        -v "content" "$INPUT_FILE")
      
      if [ "$DRY_RUN" = true ]; then
        echo "repoplay: (dry-run) Would create file '$dst'"
      else
        printf "%s" "$content" > "$dst" || \
          { echo "repoplay: Error: Failed to create file '$dst'"; exit 1; }
        log "Created $dst"
      fi
      ;;

    update)
      src=$(xmlstarlet sel -t -m "/operations/operation[@type='update' and \
        count(preceding::operation) + 1=$pos]" \
        -v "sourcePath" "$INPUT_FILE")
      content=$(xmlstarlet sel -t -m "/operations/operation[@type='update' and \
        count(preceding::operation) + 1=$pos]" \
        -v "content" "$INPUT_FILE")
      
      if [ "$DRY_RUN" = true ]; then
        echo "repoplay: (dry-run) Would update file '$src'"
      else
        printf "%s" "$content" > "$src" || \
          { echo "repoplay: Error: Failed to update file '$src'"; exit 1; }
        log "Updated $src"
      fi
      ;;

    delete)
      src=$(xmlstarlet sel -t -m "/operations/operation[@type='delete' and \
        count(preceding::operation) + 1=$pos]" \
        -v "sourcePath" "$INPUT_FILE")

      if [ "$DRY_RUN" = true ]; then
        echo "repoplay: (dry-run) Would delete file '$src'"
      else
        rm "$src" || { echo "repoplay: Error: Failed to delete file '$src'"; exit 1; }
        log "Deleted $src"
      fi
      ;;

    move)
      src=$(xmlstarlet sel -t -m "/operations/operation[@type='move' and \
        count(preceding::operation) + 1=$pos]" \
        -v "sourcePath" "$INPUT_FILE")
      dst=$(xmlstarlet sel -t -m "/operations/operation[@type='move' and \
        count(preceding::operation) + 1=$pos]" \
        -v "destinationPath" "$INPUT_FILE")

      if [ "$DRY_RUN" = true ]; then
        echo "repoplay: (dry-run) Would move file '$src' to '$dst'"
      else
        mv "$src" "$dst" || { echo "repoplay: Error: Failed to move '$src' to '$dst'"; exit 1; }
        log "Moved $src to $dst"
      fi
      ;;

    dup)
      src=$(xmlstarlet sel -t -m "/operations/operation[@type='dup' and \
        count(preceding::operation) + 1=$pos]" \
        -v "sourcePath" "$INPUT_FILE")
      dst=$(xmlstarlet sel -t -m "/operations/operation[@type='dup' and \
      count(preceding::operation) + 1=$pos]" \
        -v "destinationPath" "$INPUT_FILE")

      if [ "$DRY_RUN" = true ]; then
        echo "repoplay: (dry-run) Would copy file '$src' to '$dst'"
      else
        cp "$src" "$dst" || { echo "repoplay: Error: Failed to duplicate '$src' to '$dst'"; exit 1; }
        log "Duplicated $src to $dst"
      fi
      ;;

    *)
      echo "repoplay: Error: Unknown operation '$type'"
      exit 1
      ;;
  esac
done

# was exit 1 called inside the while loop (pipeline means an exit in the while is in a sub-process)
if [ $? -ne 0 ]; then
  cleanup
  exit 1
fi

# Delete unused backups
if [ "${#BACKUPS[@]:-0}" -gt 0 ]; then
  for backup in "${BACKUPS[@]}"; do
    rm "$backup"
    log "Removed backup $backup"
  done
fi

if [ "$DRY_RUN" = true ]; then
  log "Dry-run completed successfully"
else
  log "All operations completed successfully"
fi

